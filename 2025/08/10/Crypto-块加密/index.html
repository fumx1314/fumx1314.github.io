
  <!DOCTYPE html>
  <html lang="zh-CN"  >
  <head>
  <meta charset="utf-8">
  

  

  

  <script>window.REIMU_CONFIG = {};window.REIMU_CONFIG.icon_font = '4552607_bq08450reo';window.REIMU_CONFIG.clipboard_tips = {"success":"复制成功(*^▽^*)","fail":"复制失败 (ﾟ⊿ﾟ)ﾂ","copyright":{"enable":false,"count":50,"content":"本文版权：本博客所有文章除特别声明外，均采用 BY-NC-SA 许可协议。转载请注明出处！"}};window.REIMU_CONFIG.code_block = {"expand":true};</script>
  
  <title>
    Crypto-块加密 |
    
    KL
  </title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <link rel="preconnect" href="https://fonts.gstatic.com/" crossorigin><link rel="preload" as="style" href="https://fonts.googleapis.com/css?family=Mulish:400,400italic,700,700italic%7CNoto%20Serif%20SC:400,400italic,700,700italic&display=swap"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Mulish:400,400italic,700,700italic%7CNoto%20Serif%20SC:400,400italic,700,700italic&display=swap" media="print" onload="this.media&#x3D;&#39;all&#39;">
  
    <link rel="preload" href="//at.alicdn.com/t/c/font_4552607_bq08450reo.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  
  
    
<link rel="stylesheet" href="/css/loader.css">

  
  
    <meta name="description" content="AES 一种对称、分组加密算法  三个基本概念 密钥、填充、模式  密钥 AES 支持 3 种长度的密码 128 位、192 位、256 位。 从安全性来看，AES256 安全性最高。从性能来看，AES128 性能最高 AES 的加密标准中，每个分组的 长度固定为 128bits (16Bytes)，密钥长度为 128bits，192bits，256bits, 不同的密钥长度有不同的加密轮数，根">
<meta property="og:type" content="article">
<meta property="og:title" content="Crypto-块加密">
<meta property="og:url" content="http://example.com/2025/08/10/Crypto-%E5%9D%97%E5%8A%A0%E5%AF%86/index.html">
<meta property="og:site_name" content="KL">
<meta property="og:description" content="AES 一种对称、分组加密算法  三个基本概念 密钥、填充、模式  密钥 AES 支持 3 种长度的密码 128 位、192 位、256 位。 从安全性来看，AES256 安全性最高。从性能来看，AES128 性能最高 AES 的加密标准中，每个分组的 长度固定为 128bits (16Bytes)，密钥长度为 128bits，192bits，256bits, 不同的密钥长度有不同的加密轮数，根">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2025/08/10/images/1-17547940186221.png">
<meta property="og:image" content="http://example.com/2025/08/10/images/2-17547940186235.png">
<meta property="og:image" content="http://example.com/2025/08/10/images/3-17547940186233.png">
<meta property="og:image" content="http://example.com/2025/08/10/images/14.png">
<meta property="og:image" content="http://example.com/2025/08/10/images/15.png">
<meta property="og:image" content="http://example.com/2025/08/10/images/16.png">
<meta property="og:image" content="http://example.com/2025/08/10/images/17.png">
<meta property="og:image" content="http://example.com/2025/08/10/images/1-175482370573918.png">
<meta property="og:image" content="http://example.com/2025/08/10/images/2-175482389788521.png">
<meta property="og:image" content="http://example.com/2025/08/10/images/3-175482448111324.png">
<meta property="og:image" content="http://example.com/2025/08/10/images/4-175482456689627.png">
<meta property="og:image" content="http://example.com/2025/08/10/images/5-175482467513831.png">
<meta property="og:image" content="http://example.com/2025/08/10/images/6-175482467513933.png">
<meta property="og:image" content="http://example.com/2025/08/10/images/7-175482467513935.png">
<meta property="og:image" content="http://example.com/2025/08/10/images/8-175482467513937.png">
<meta property="og:image" content="http://example.com/2025/08/10/images/9-175482467513940.png">
<meta property="og:image" content="http://example.com/2025/08/10/images/10.png">
<meta property="og:image" content="http://example.com/2025/08/10/images/11.png">
<meta property="og:image" content="http://example.com/2025/08/10/images/12.png">
<meta property="og:image" content="http://example.com/2025/08/10/images/13-175482467513944.png">
<meta property="og:image" content="http://example.com/2025/08/10/images/14-175482467513830.png">
<meta property="og:image" content="http://example.com/2025/08/10/images/CBC-example.png">
<meta property="article:published_time" content="2025-08-10T02:39:43.000Z">
<meta property="article:modified_time" content="2025-09-27T08:55:04.784Z">
<meta property="article:author" content="FuB0Y">
<meta property="article:tag" content="crypto">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2025/08/10/images/1-17547940186221.png">
  
  
    <link rel="alternate" href="/atom.xml" title="KL" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/images/favicon.ico">
  
  
<link rel="stylesheet" href="/css/style.css">

  <link rel="preload" href="https://npm.webcache.cn/photoswipe@5.4.4/dist/photoswipe.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
  
    
      
        
<link rel="stylesheet" href="https://npm.webcache.cn/katex@0.16.11/dist/katex.min.css">

      
    
  
  
  
  
    
<script src="https://npm.webcache.cn/pace-js@1.2.4/pace.min.js" integrity="sha384-k6YtvFUEIuEFBdrLKJ3YAUbBki333tj1CSUisai5Cswsg9wcLNaPzsTHDswp4Az8" crossorigin="anonymous"></script>

  
  
    
<link rel="stylesheet" href="https://npm.webcache.cn/@reimujs/aos@0.1.0/dist/aos.css">

  
  
<meta name="generator" content="Hexo 7.3.0"></head>

  <body>
    
  <div id='loader'>
    <div class="loading-left-bg loading-bg"></div>
    <div class="loading-right-bg loading-bg"></div>
    <div class="spinner-box">
      <div class="loading-taichi">
        
          <svg width="150" height="150" viewBox="0 0 1024 1024" class="icon" version="1.1" xmlns="https://www.w3.org/2000/svg" shape-rendering="geometricPrecision">
            <path d="M303.5 432A80 80 0 0 1 291.5 592A80 80 0 0 1 303.5 432z" fill="var(--red-1, #ff5252)" />
            <path d="M512 65A447 447 0 0 1 512 959L512 929A417 417 0 0 0 512 95A417 417 0 0 0 512 929L512 959A447 447 0 0 1 512 65z 
           M512 95A417 417 0 0 1 929 512A208.5 208.5 0 0 1 720.5 720.5L720.5 592A80 80 0 0 0 720.5 432A80 80 0 0 0 720.5 592L720.5 720.5A208.5 208.5 0 0 1 512 512A208.5 208.5 0 0 0 303.5 303.5A208.5 208.5 0 0 0 95 512A417 417 0 0 1 512 95z" fill="var(--red-1, #ff5252)" />
          </svg>
        
      </div>
      <div class="loading-word">少女祈祷中...</div>
    </div>
  </div>
  </div>
  <script>
    var time = null;
    var startLoading = () => {
      time = Date.now();
      document.getElementById('loader').classList.remove("loading");
    }
    var endLoading = () => {
      if (!time) {
        document.body.style.overflow = 'auto';
        document.getElementById('loader').classList.add("loading");
      } else {
        if (Date.now() - time > 500) {
          time = null;
          document.body.style.overflow = 'auto';
          document.getElementById('loader').classList.add("loading");
        } else {
          setTimeout(endLoading, 500 - (Date.now() - time));
          time = null;
        }
      }
    }
    window.addEventListener('DOMContentLoaded', endLoading);
    document.getElementById('loader').addEventListener('click', endLoading);
  </script>

<div id="copy-tooltip" style="pointer-events: none; opacity: 0; transition: all 0.2s ease; position: fixed;top: 50%;left: 50%;z-index: 999;transform: translate(-50%, -50%);color: white;background: rgba(0, 0, 0, 0.5);padding: 10px 15px;border-radius: 10px;">
</div>


    <div id="container">
      <div id="wrap">
        <div id="header-nav">
  <nav id="main-nav">
    
      
        <span class="main-nav-link-wrap">
          <div class="main-nav-icon icon rotate">
            &#xe62b;
          </div>
          <a class="main-nav-link" href="/">首页</a>
        </span>
      
        <span class="main-nav-link-wrap">
          <div class="main-nav-icon icon rotate">
            &#xe62b;
          </div>
          <a class="main-nav-link" href="/archives">归档</a>
        </span>
      
        <span class="main-nav-link-wrap">
          <div class="main-nav-icon icon rotate">
            &#xe62b;
          </div>
          <a class="main-nav-link" href="/about">关于</a>
        </span>
      
        <span class="main-nav-link-wrap">
          <div class="main-nav-icon icon rotate">
            &#xe62b;
          </div>
          <a class="main-nav-link" href="/friend">友链</a>
        </span>
      
    
    <a id="main-nav-toggle" class="nav-icon"></a>
  </nav>
  <nav id="sub-nav">
    
      <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅" target="_blank"></a>
    
    
    
  </nav>
</div>
<header id="header">
  
    <picture>
      
    </picture>
    
      <img fetchpriority="high" src="/images/banner.webp" alt="Crypto-块加密">
    
  
  <div id="header-outer">
    <div id="header-title">
      
        
        
          <a href="/" id="logo">
            <h1 data-aos="slide-up">Crypto-块加密</h1>
          </a>
        
      
      
        
        <h2 id="subtitle-wrap" data-aos="slide-down">
          
        </h2>
      
    </div>
  </div>
</header>

        <div id="content"  class="sidebar-right" >
          <aside id="sidebar">
  
  
  <div class="sidebar-wrapper wrap-sticky">
    <div class="sidebar-wrap" data-aos="fade-up">
      
        <div class="sidebar-toc-sidebar"><div class="sidebar-toc">
  <h3 class="toc-title">文章目录</h3>
  <div class="sidebar-toc-wrapper toc-div-class" >
      
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#aes"><span class="toc-number">1.</span> <span class="toc-text"> AES</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E4%B8%AA%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.</span> <span class="toc-text"> 三个基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%86%E9%92%A5"><span class="toc-number">1.1.1.</span> <span class="toc-text"> 密钥</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A1%AB%E5%85%85"><span class="toc-number">1.1.2.</span> <span class="toc-text"> 填充</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.1.3.</span> <span class="toc-text"> 模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ecb-%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.1.3.1.</span> <span class="toc-text"> ECB 模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#cbc-%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.1.3.2.</span> <span class="toc-text"> CBC 模式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#aes-%E5%8A%A0%E5%AF%86%E6%B5%81%E7%A8%8B"><span class="toc-number">1.2.</span> <span class="toc-text"> AES 加密流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#aes-ecb-%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.3.</span> <span class="toc-text"> AES-ECB 模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.3.1.</span> <span class="toc-text"> 代码示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#aes-cbc-%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.4.</span> <span class="toc-text"> AES-CBC 模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E5%AF%86%E8%BF%87%E7%A8%8B"><span class="toc-number">1.4.1.</span> <span class="toc-text"> 加密过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%AF%86%E8%BF%87%E7%A8%8B"><span class="toc-number">1.4.2.</span> <span class="toc-text"> 解密过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.4.3.</span> <span class="toc-text"> 代码实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98"><span class="toc-number">1.5.</span> <span class="toc-text"> 例题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#babyaes%E5%B7%B2%E7%9F%A5iv%E5%AF%86%E6%96%87%E5%AF%86%E9%92%A5"><span class="toc-number">1.5.1.</span> <span class="toc-text"> BabyAES（已知iv,密文,密钥）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2020-%E5%B9%B4%E7%AC%AC%E4%B8%89%E5%B1%8A%E5%AE%89%E6%B4%B5%E6%9D%AF-easyaes"><span class="toc-number">1.5.2.</span> <span class="toc-text"> [2020 年第三届安洵杯] easyaes</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#aes-2"><span class="toc-number">1.5.3.</span> <span class="toc-text"> aes</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#moectf-ez_cbc"><span class="toc-number">1.5.4.</span> <span class="toc-text"> moectf ez_cbc</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#moectf-ez_chain"><span class="toc-number">1.5.5.</span> <span class="toc-text"> moectf ez_chain</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#afctf-myowncbc"><span class="toc-number">1.5.6.</span> <span class="toc-text"> Afctf MyOwnCBC</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#des"><span class="toc-number">2.</span> <span class="toc-text"> DES</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">2.1.</span> <span class="toc-text"> 简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#feistel-%E7%BD%91%E7%BB%9C"><span class="toc-number">2.2.</span> <span class="toc-text"> Feistel 网络</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#des%E5%8A%A0%E5%AF%86%E6%B5%81%E7%A8%8B"><span class="toc-number">2.3.</span> <span class="toc-text"> DES加密流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E7%BD%AE%E6%8D%A2"><span class="toc-number">2.3.1.</span> <span class="toc-text"> 初始置换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AE%E5%87%BD%E6%95%B0-f"><span class="toc-number">2.3.2.</span> <span class="toc-text"> 轮函数 F</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8B%93%E5%B1%95%E7%BD%AE%E6%8D%A2"><span class="toc-number">2.3.2.1.</span> <span class="toc-text"> 拓展置换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#s-%E7%9B%92%E7%BD%AE%E6%8D%A2"><span class="toc-number">2.3.2.2.</span> <span class="toc-text"> S 盒置换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#p-%E7%BD%AE%E6%8D%A2"><span class="toc-number">2.3.2.3.</span> <span class="toc-text"> P 置换</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%86%E5%88%9D%E5%A7%8B%E7%BD%AE%E6%8D%A2"><span class="toc-number">2.3.3.</span> <span class="toc-text"> 逆初始置换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%86%E9%92%A5%E7%94%9F%E6%88%90"><span class="toc-number">2.4.</span> <span class="toc-text"> 密钥生成</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#pc-1-%E7%BD%AE%E6%8D%A2"><span class="toc-number">2.4.1.</span> <span class="toc-text"> PC-1 置换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A6%E7%A7%BB%E5%A4%84%E7%90%86"><span class="toc-number">2.4.2.</span> <span class="toc-text"> 左移处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pc-2-%E7%BD%AE%E6%8D%A2"><span class="toc-number">2.4.3.</span> <span class="toc-text"> PC-2 置换</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cbc%E5%AD%97%E8%8A%82%E7%BF%BB%E8%BD%AC"><span class="toc-number">3.</span> <span class="toc-text"> CBC字节翻转</span></a></li></ol>
      
  </div>
</div>
</div>
        <div class="sidebar-common-sidebar hidden"><div class="sidebar-author">
  <img data-src="/avatar/avatar.jpg" data-sizes="auto" alt="FuB0Y" class="lazyload">
  <div class="sidebar-author-name">FuB0Y</div>
  <div class="sidebar-description">世所谓英雄者，不以挫抑而灰心，不以失败而退怯</div>
</div>
<div class="sidebar-state">
  <div class="sidebar-state-article">
    <div>文章</div>
    <div class="sidebar-state-number">186</div>
  </div>
  <div class="sidebar-state-category">
    <div>分类</div>
    <div class="sidebar-state-number">4</div>
  </div>
  <div class="sidebar-state-tag">
    <div>标签</div>
    <div class="sidebar-state-number">179</div>
  </div>
</div>
<div class="sidebar-social">
  
</div>
<div class="sidebar-menu">
  
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/" aria-label="首页"></a>
        <div class="sidebar-menu-icon icon rotate">
          &#xe62b;
        </div>
        <div class="sidebar-menu-link">首页</div>
      </div>
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/archives" aria-label="归档"></a>
        <div class="sidebar-menu-icon icon rotate">
          &#xe62b;
        </div>
        <div class="sidebar-menu-link">归档</div>
      </div>
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/about" aria-label="关于"></a>
        <div class="sidebar-menu-icon icon rotate">
          &#xe62b;
        </div>
        <div class="sidebar-menu-link">关于</div>
      </div>
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/friend" aria-label="友链"></a>
        <div class="sidebar-menu-icon icon rotate">
          &#xe62b;
        </div>
        <div class="sidebar-menu-link">友链</div>
      </div>
    
  
</div>
</div>
      
      
        <div class="sidebar-btn-wrapper" style="position:static">
          <div class="sidebar-toc-btn current"></div>
          <div class="sidebar-common-btn"></div>
        </div>
      
    </div>
  </div>

  <div class="sidebar-widget">
  
  </div>
</aside>

          <section id="main"><article id="post-Crypto-块加密" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner" data-aos="fade-up">
    <div class="article-meta">
      <div class="article-date">
  <a href="/2025/08/10/Crypto-%E5%9D%97%E5%8A%A0%E5%AF%86/" class="article-date-link" data-aos="zoom-in">
    <time datetime="2025-08-10T02:39:43.000Z" itemprop="datePublished">2025-08-10</time>
    <time style="display: none;" id="post-update-time">2025-09-27</time>
  </a>
</div>

      
  <div class="article-category">
    <a class="article-category-link" href="/categories/crypto/" data-aos="zoom-in">crypto</a>
  </div>


    </div>
    <div class="hr-line"></div>
    

    <div class="e-content article-entry" itemprop="articleBody">
      
      
        <h2 id="aes"><a class="markdownIt-Anchor" href="#aes"></a> AES</h2>
<p>一种对称、分组加密算法</p>
<h3 id="三个基本概念"><a class="markdownIt-Anchor" href="#三个基本概念"></a> 三个基本概念</h3>
<p><strong>密钥、填充、模式</strong></p>
<h4 id="密钥"><a class="markdownIt-Anchor" href="#密钥"></a> 密钥</h4>
<p>AES 支持 3 种长度的密码 128 位、192 位、256 位。</p>
<p>从安全性来看，AES256 安全性最高。从性能来看，AES128 性能最高</p>
<p>AES 的加密标准中，每个分组的 长度固定为 128bits (16Bytes)，密钥长度为 128bits，192bits，256bits, 不同的密钥长度有不同的加密轮数，根据长度不同可以分为 AES-128，AES-192，AES-256。</p>
<table>
<thead>
<tr>
<th>AES 加密</th>
<th>密钥长度</th>
<th>分组长度</th>
<th>加密轮数</th>
</tr>
</thead>
<tbody>
<tr>
<td>AES-128</td>
<td>128bits</td>
<td>128bits</td>
<td>10</td>
</tr>
<tr>
<td>AES-192</td>
<td>192bits</td>
<td>128bits</td>
<td>12</td>
</tr>
<tr>
<td>AES-256</td>
<td>256bits</td>
<td>128bits</td>
<td>14</td>
</tr>
</tbody>
</table>
<h4 id="填充"><a class="markdownIt-Anchor" href="#填充"></a> 填充</h4>
<p>在 AES 加密中 有六种填充模式，分别为 <strong>NoPadding, PKCS#5, PKCS#7, ISO 10126, ANSI X9.23 和 ZerosPadding</strong> 。</p>
<ul>
<li>Nopadding ：不进行填充</li>
<li>ZerosPadding：缺少的字节全部使用 0x00 填充</li>
<li>PKCS#5 &amp; PKCS#7：缺少几个字节就填充几个字节，值为填充的字符数</li>
</ul>
<blockquote>
<p>例如，AAAAAAAA BBBBBBBB CCCCCCCC 刚好分成 3 个分组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AAAAAAAA  BBBBBBBB CCCCC\____    缺少3个字节 所以使用 0x03进行填充      </span><br></pre></td></tr></table></figure>
<p>(这里例子的 A B C 均视为一个字节 以 pkcs5 为例 8 个字节为一组)</p>
<p>如果明文块小于 16 个字节 (128bit) 那么在明文块末尾补足响应数量的字符，且每个字符的值为填充字符数（缺少的字符数）</p>
<p>比如明文按照 16 个字节为一组的话：{1,2,3,4,5,a,b,c,d,e}，缺少 6 个字节【128/8-10=6】，则补全为 {1,2,3,4,5,a,b,c,d,e,6,6,6,6,6,6}</p>
<p>【不同在于 PKCS5 限定了块大小为 8bytes，而 PKCS7 没有限定，在 AES 加密当中严格来说是不能使用 pkcs5 的，因为 AES 的块大小是 <strong>16bytes</strong>，而 pkcs5 只能用于 <strong>8bytes</strong>，通常我们在 AES 加密中所说的 pkcs5 指的就是 pkcs7】</p>
</blockquote>
<ul>
<li>ISO 10126：最后一个字节是填充的字节数（包括最后一字节），其他全部填随机数</li>
</ul>
<blockquote>
<p>… | DD DD DD DD DD DD DD DD | DD DD DD DD 81 A6 23 04 | …</p>
</blockquote>
<ul>
<li>ANSI X9.23：和 ISO 10126 相似，最后一个字节是填充的字节数，区别在 这种方法填充的其他字节都是 0，而不是随机数</li>
</ul>
<blockquote>
<p>… | DD DD DD DD DD DD DD DD | DD DD DD DD 00 00 00 04 | …</p>
</blockquote>
<h4 id="模式"><a class="markdownIt-Anchor" href="#模式"></a> 模式</h4>
<p>AES 分组加密的加密模式共五种可选加密模式。（如果在加密时使用了某种工作模式，则解密时也必须使用同种工作模式）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ECB模式（电子密码本模式：Electronic codebook）</span><br><span class="line">　　ECB是最简单的块密码加密模式，加密前根据加密块大小（如AES为128位）分成若干块，之后将每块使用相同的密钥单独加密，解密同理。</span><br><span class="line"></span><br><span class="line">CBC模式（密码分组链接：Cipher-block chaining）</span><br><span class="line">　　CBC模式对于每个待加密的密码块在加密前会先与前一个密码块的密文异或然后再用加密器加密。第一个明文块与一个叫初始化向量的数据块异或</span><br><span class="line">　　CBC加密：https://www.cnblogs.com/phoenixy/p/15793339.html</span><br><span class="line"></span><br><span class="line">CTR模式（计数器模式）</span><br><span class="line">　　CTR模式是一种通过将逐次累加的计数器进行加密来生成密钥流的流密码。自增的算子用密钥加密之后的输出和明文异或的结果得到密文，相当于一次一密。</span><br><span class="line">　　这种加密方式简单快速，安全可靠，而且可以并行加密，但是在计算器不能维持很长的情况下，密钥只能使用一次。 </span><br><span class="line"></span><br><span class="line">CFB模式(密文反馈:Cipher feedback)</span><br><span class="line"> 　　与ECB和CBC模式只能够加密块数据不同，CFB能够将块密文（Block Cipher）转换为流密文（Stream Cipher）</span><br><span class="line"></span><br><span class="line">OFB模式（输出反馈：Output feedback）</span><br><span class="line"> 　　OFB是先用块加密器生成密钥流（Keystream），然后再将密钥流与明文流异或得到密文流，解密是先用块加密器生成密钥流，再将密钥流与密文流异或得到明文，由于异或操作的对称性所以加密和解密的流程是完全一样的。</span><br></pre></td></tr></table></figure>
<p>在 CTF 中比较常见的为 <strong>ECB 模式</strong>和 <strong>CBC 模式</strong>，都属于分组密码算法（分组密码算法有四种模式：CBC/ECB/CFB/OCB），主要介绍下 ECB 模式和 CBC 模式。</p>
<h5 id="ecb-模式"><a class="markdownIt-Anchor" href="#ecb-模式"></a> ECB 模式</h5>
<p>ECB 模式 (电话本)，依次出来一组明文分块，每次使用相同的密钥加密。</p>
<p>其加密模式如下所示，如果加密的明文块内容相同，那么得到的密文块也就会相同，相对来说不够安全，只适用于明文较短时。</p>
<p><img src="../images/1-17547940186221.png" alt="img" /></p>
<h5 id="cbc-模式"><a class="markdownIt-Anchor" href="#cbc-模式"></a> CBC 模式</h5>
<p>CBC 模式 (密文分组链接)，一次处理一组明文分块，每次使用相同的密钥加密。CBC 模式主要引用了一个初始化向量 (IV) 来加强密码的随机性，保证相同明文通过相同密钥的加密结果不同。</p>
<p><img src="../images/2-17547940186235.png" alt="img" /></p>
<h3 id="aes-加密流程"><a class="markdownIt-Anchor" href="#aes-加密流程"></a> AES 加密流程</h3>
<p>简要步骤如下图所示：</p>
<p><img src="../images/3-17547940186233.png" alt="img" /></p>
<ol>
<li>
<p>将明文按照 128bit 进行分组，拆分次若干个明文块；</p>
</li>
<li>
<p>按照选择的填充模式对最后一块明文块进行填充；</p>
</li>
<li>
<p>每个明文块利用 AES 加密器和密钥进行加密，得到对应的密文块；</p>
</li>
<li>
<p>拼接所有的密文块得到最终加密的密文。</p>
</li>
</ol>
<h3 id="aes-ecb-模式"><a class="markdownIt-Anchor" href="#aes-ecb-模式"></a> AES-ECB 模式</h3>
<p><img src="../images/14.png" alt="img" /></p>
<ol>
<li>
<p>明文经过填充后，分为不同的组 block，以组的方式对数据进行处理</p>
</li>
<li>
<p>密钥 Key 对明文块进行块加密，得到密文块</p>
</li>
<li>
<p>密文块拼接后得到加密后的密文</p>
</li>
</ol>
<h4 id="代码示例"><a class="markdownIt-Anchor" href="#代码示例"></a> 代码示例</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># aes_ecb.py</span></span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Union</span></span><br><span class="line"></span><br><span class="line">BLOCK_SIZE = <span class="number">16</span>  <span class="comment"># AES块大小（字节）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pkcs7_pad</span>(<span class="params">data: <span class="built_in">bytes</span></span>) -&gt; <span class="built_in">bytes</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;PKCS#7 填充到 16 字节对齐&quot;&quot;&quot;</span></span><br><span class="line">    pad_len = BLOCK_SIZE - (<span class="built_in">len</span>(data) % BLOCK_SIZE)</span><br><span class="line">    <span class="keyword">return</span> data + <span class="built_in">bytes</span>([pad_len]) * pad_len</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pkcs7_unpad</span>(<span class="params">padded: <span class="built_in">bytes</span></span>) -&gt; <span class="built_in">bytes</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;去掉 PKCS#7 填充（简单校验）&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> padded <span class="keyword">or</span> <span class="built_in">len</span>(padded) % BLOCK_SIZE != <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&quot;输入长度不是 AES 块大小的整数倍&quot;</span>)</span><br><span class="line">    pad_len = padded[-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> pad_len &lt; <span class="number">1</span> <span class="keyword">or</span> pad_len &gt; BLOCK_SIZE:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&quot;无效的填充长度&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> padded[-pad_len:] != <span class="built_in">bytes</span>([pad_len]) * pad_len:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&quot;填充错误&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> padded[:-pad_len]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">aes_ecb_encrypt</span>(<span class="params">plaintext: <span class="type">Union</span>[<span class="built_in">str</span>, <span class="built_in">bytes</span>], key: <span class="type">Union</span>[<span class="built_in">str</span>, <span class="built_in">bytes</span>]</span>) -&gt; <span class="built_in">bytes</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    使用 AES-ECB 模式加密数据</span></span><br><span class="line"><span class="string">    :param plaintext: 明文数据（str 或 bytes）</span></span><br><span class="line"><span class="string">    :param key: 密钥（str 或 bytes），长度必须为 16/24/32 字节（AES-128/192/256）</span></span><br><span class="line"><span class="string">    :return: 密文（bytes）</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    步骤：</span></span><br><span class="line"><span class="string">    1. 确保明文与密钥是 bytes 类型</span></span><br><span class="line"><span class="string">    2. 检查密钥长度是否合法</span></span><br><span class="line"><span class="string">    3. 创建 AES-ECB 加密器</span></span><br><span class="line"><span class="string">    4. 对明文进行 PKCS#7 填充</span></span><br><span class="line"><span class="string">    5. 加密并返回密文字节</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(plaintext, <span class="built_in">str</span>):</span><br><span class="line">        plaintext = plaintext.encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(key, <span class="built_in">str</span>):</span><br><span class="line">        key = key.encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(key) <span class="keyword">not</span> <span class="keyword">in</span> (<span class="number">16</span>, <span class="number">24</span>, <span class="number">32</span>):</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&quot;AES key 长度必须为 16/24/32 字节&quot;</span>)</span><br><span class="line"></span><br><span class="line">    cipher = AES.new(key, AES.MODE_ECB)<span class="comment"># 创建 AES ECB 模式实例</span></span><br><span class="line">    padded = pkcs7_pad(plaintext)<span class="comment"># 填充明文</span></span><br><span class="line">    ciphertext = cipher.encrypt(padded)<span class="comment"># 加密</span></span><br><span class="line">    <span class="keyword">return</span> ciphertext</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">aes_ecb_decrypt</span>(<span class="params">ciphertext: <span class="built_in">bytes</span>, key: <span class="type">Union</span>[<span class="built_in">str</span>, <span class="built_in">bytes</span>]</span>) -&gt; <span class="built_in">bytes</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    使用 AES-ECB 模式解密数据</span></span><br><span class="line"><span class="string">    :param ciphertext: 密文（bytes）</span></span><br><span class="line"><span class="string">    :param key: 密钥（str 或 bytes）</span></span><br><span class="line"><span class="string">    :return: 明文（bytes）</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    步骤：</span></span><br><span class="line"><span class="string">    1. 确保密钥是 bytes 类型</span></span><br><span class="line"><span class="string">    2. 检查密钥长度是否合法</span></span><br><span class="line"><span class="string">    3. 创建 AES-ECB 解密器</span></span><br><span class="line"><span class="string">    4. 解密得到带填充的明文</span></span><br><span class="line"><span class="string">    5. 去除填充后返回原始明文</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(key, <span class="built_in">str</span>):</span><br><span class="line">        key = key.encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(key) <span class="keyword">not</span> <span class="keyword">in</span> (<span class="number">16</span>, <span class="number">24</span>, <span class="number">32</span>):</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&quot;AES key 长度必须为 16/24/32 字节&quot;</span>)</span><br><span class="line"></span><br><span class="line">    cipher = AES.new(key, AES.MODE_ECB)<span class="comment"># 创建 AES ECB 模式实例</span></span><br><span class="line">    padded = cipher.decrypt(ciphertext)<span class="comment"># 解密得到填充数据</span></span><br><span class="line">    <span class="keyword">return</span> pkcs7_unpad(padded)<span class="comment"># 去除填充</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 辅助：把密文表示为 hex / base64</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">to_hex</span>(<span class="params">b: <span class="built_in">bytes</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="keyword">return</span> b.<span class="built_in">hex</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">to_base64</span>(<span class="params">b: <span class="built_in">bytes</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="keyword">return</span> base64.b64encode(b).decode(<span class="string">&#x27;ascii&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">from_hex</span>(<span class="params">h: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bytes</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bytes</span>.fromhex(h)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">from_base64</span>(<span class="params">s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bytes</span>:</span><br><span class="line">    <span class="keyword">return</span> base64.b64decode(s)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试示例</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    key = <span class="string">&quot;thisisakey123456&quot;</span>   <span class="comment"># 16 字节</span></span><br><span class="line">    pt = <span class="string">&quot;hello AES-ECB! 测试中文&quot;</span>  <span class="comment"># 任意字符串</span></span><br><span class="line"></span><br><span class="line">    ct = aes_ecb_encrypt(pt, key)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;cipher (hex):&quot;</span>, to_hex(ct))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;cipher (base64):&quot;</span>, to_base64(ct))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 解密回明文</span></span><br><span class="line">    pt2 = aes_ecb_decrypt(ct, key)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;decrypted:&quot;</span>, pt2.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="aes-cbc-模式"><a class="markdownIt-Anchor" href="#aes-cbc-模式"></a> AES-CBC 模式</h3>
<h4 id="加密过程"><a class="markdownIt-Anchor" href="#加密过程"></a> 加密过程</h4>
<p><img src="../images/15.png" alt="img" /></p>
<ol>
<li>
<p>明文经过填充后，分为不同的组 block，以组的方式对数据进行处理</p>
</li>
<li>
<p>初始化向量 IV 首先和第一组明文进行 XOR 得到中间值 Midvalue</p>
</li>
<li>
<p>采用密钥 Key 对中间值 Midvalue 进行块加密，删除第一组加密的密文</p>
</li>
<li>
<p>第一组加密的密文 作为第二组的初始化向量 IV，参与第二组的明文异或操作</p>
</li>
<li>
<p>依次进行块加密，最终将得到的每一块密文拼接成密文</p>
</li>
</ol>
<h4 id="解密过程"><a class="markdownIt-Anchor" href="#解密过程"></a> 解密过程</h4>
<p><img src="../images/16.png" alt="img" /></p>
<ol>
<li>将密文进行分组，第一组得到的是初始化向量，从第二组开始才是真正的密文</li>
<li>使用加密密钥 Key 对密文的第一组进行解密，得到中间值 Midvalue</li>
<li>中间值 Midvalue 和 IV 进行 XOR, 得到该组的明文</li>
<li>前一块密文是最后一块密文的 IV，通过异或中间值得到明文</li>
<li>块全部解密完成后拼接得到明文，密码算法校验明文填充格式是否正确</li>
<li>校验通过得到明文，校验失败则得到密文</li>
</ol>
<h4 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">from</span> Crypto.Random <span class="keyword">import</span> get_random_bytes</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"><span class="comment"># ===== PKCS7 填充函数 =====</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pkcs7_pad</span>(<span class="params">data: <span class="built_in">bytes</span>, block_size: <span class="built_in">int</span> = <span class="number">16</span></span>) -&gt; <span class="built_in">bytes</span>:</span><br><span class="line">    pad_len = block_size - (<span class="built_in">len</span>(data) % block_size)  <span class="comment"># 需要补多少个字节</span></span><br><span class="line">    <span class="keyword">return</span> data + <span class="built_in">bytes</span>([pad_len] * pad_len)  <span class="comment"># 用 pad_len 这个值补 pad_len 次</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ===== PKCS7 去填充函数 =====</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pkcs7_unpad</span>(<span class="params">data: <span class="built_in">bytes</span></span>) -&gt; <span class="built_in">bytes</span>:</span><br><span class="line">    pad_len = data[-<span class="number">1</span>]  <span class="comment"># 取最后一个字节，看看填充了多少</span></span><br><span class="line">    <span class="keyword">return</span> data[:-pad_len]  <span class="comment"># 去掉填充的字节</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ===== AES-CBC 加密 =====</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">aes_cbc_encrypt</span>(<span class="params">key: <span class="built_in">bytes</span>, plaintext: <span class="built_in">bytes</span></span>) -&gt; <span class="built_in">tuple</span>[<span class="built_in">bytes</span>, <span class="built_in">bytes</span>]:</span><br><span class="line">    iv = get_random_bytes(<span class="number">16</span>)  <span class="comment"># CBC 模式需要 16 字节随机 IV</span></span><br><span class="line">    cipher = AES.new(key, AES.MODE_CBC, iv)  <span class="comment"># 创建 AES-CBC 加密器</span></span><br><span class="line">    padded_data = pkcs7_pad(plaintext)  <span class="comment"># PKCS7 填充</span></span><br><span class="line">    ciphertext = cipher.encrypt(padded_data)  <span class="comment"># 加密</span></span><br><span class="line">    <span class="keyword">return</span> iv, ciphertext</span><br><span class="line"></span><br><span class="line"><span class="comment"># ===== AES-CBC 解密 =====</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">aes_cbc_decrypt</span>(<span class="params">key: <span class="built_in">bytes</span>, iv: <span class="built_in">bytes</span>, ciphertext: <span class="built_in">bytes</span></span>) -&gt; <span class="built_in">bytes</span>:</span><br><span class="line">    cipher = AES.new(key, AES.MODE_CBC, iv)  <span class="comment"># 创建 AES-CBC 解密器</span></span><br><span class="line">    padded_plaintext = cipher.decrypt(ciphertext)  <span class="comment"># 解密</span></span><br><span class="line">    <span class="keyword">return</span> pkcs7_unpad(padded_plaintext)  <span class="comment"># 去掉填充</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ===== 示例 =====</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    key = get_random_bytes(<span class="number">16</span>)  <span class="comment"># AES-128 的密钥（16字节）</span></span><br><span class="line">    plaintext = <span class="string">b&quot;Hello, CTF! AES-CBC demo.&quot;</span>  <span class="comment"># 明文</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;原文:&quot;</span>, plaintext)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 加密</span></span><br><span class="line">    iv, ciphertext = aes_cbc_encrypt(key, plaintext)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;IV(base64):&quot;</span>, base64.b64encode(iv).decode())</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;密文(base64):&quot;</span>, base64.b64encode(ciphertext).decode())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 解密</span></span><br><span class="line">    decrypted = aes_cbc_decrypt(key, iv, ciphertext)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;解密结果:&quot;</span>, decrypted)</span><br></pre></td></tr></table></figure>
<h3 id="例题"><a class="markdownIt-Anchor" href="#例题"></a> 例题</h3>
<h4 id="babyaes已知iv密文密钥"><a class="markdownIt-Anchor" href="#babyaes已知iv密文密钥"></a> BabyAES（已知iv,密文,密钥）</h4>
<p>题目：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">iv = os.urandom(<span class="number">16</span>)</span><br><span class="line">key = os.urandom(<span class="number">16</span>)</span><br><span class="line">my_aes = AES.new(key, AES.MODE_CBC, iv)</span><br><span class="line">flag = <span class="built_in">open</span>(<span class="string">&#x27;flag.txt&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>).read()</span><br><span class="line">flag += (<span class="number">16</span> - <span class="built_in">len</span>(flag) % <span class="number">16</span>) * <span class="string">b&#x27;\x00&#x27;</span></span><br><span class="line">c = my_aes.encrypt(flag)</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"><span class="built_in">print</span>(iv)</span><br><span class="line"><span class="built_in">print</span>(key)</span><br><span class="line"> </span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">b&#x27;C4:\x86Q$\xb0\xd1\x1b\xa9L\x00\xad\xa3\xff\x96 hJ\x1b~\x1c\xd1y\x87A\xfe0\xe2\xfb\xc7\xb7\x7f^\xc8\x9aP\xdaX\xc6\xdf\x17l=K\x95\xd07&#x27;</span></span><br><span class="line"><span class="string">b&#x27;\xd1\xdf\x8f)\x08w\xde\xf9yX%\xca[\xcb\x18\x80&#x27;</span></span><br><span class="line"><span class="string">b&#x27;\xa4\xa6M\xab&#123;\xf6\x97\x94&gt;hK\x9bBe]F&#x27;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<p>题目分析： 已知 iv key 密文 c 使用 AES-CBC 模式，全部已知可直接 AES 解密得到明文 flag</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line">c = <span class="string">b&#x27;C4:\x86Q$\xb0\xd1\x1b\xa9L\x00\xad\xa3\xff\x96 hJ\x1b~\x1c\xd1y\x87A\xfe0\xe2\xfb\xc7\xb7\x7f^\xc8\x9aP\xdaX\xc6\xdf\x17l=K\x95\xd07&#x27;</span></span><br><span class="line">iv = <span class="string">b&#x27;\xd1\xdf\x8f)\x08w\xde\xf9yX%\xca[\xcb\x18\x80&#x27;</span></span><br><span class="line">key = <span class="string">b&#x27;\xa4\xa6M\xab&#123;\xf6\x97\x94&gt;hK\x9bBe]F&#x27;</span></span><br><span class="line"> </span><br><span class="line">Cipher = AES.new(key,AES.MODE_CBC,iv)</span><br><span class="line">decrypted = Cipher.decrypt(c)</span><br><span class="line"><span class="built_in">print</span>(decrypted)</span><br><span class="line"><span class="comment"># b&#x27;Dest0g3&#123;d0e5fa76-e50f-76f6-9cf1-b6c2d576b6f4&#125;\x00\x00\x00&#x27;</span></span><br></pre></td></tr></table></figure>
<h4 id="2020-年第三届安洵杯-easyaes"><a class="markdownIt-Anchor" href="#2020-年第三届安洵杯-easyaes"></a> [2020 年第三届安洵杯] easyaes</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> bytes_to_long</span><br><span class="line"><span class="keyword">from</span> flag <span class="keyword">import</span> flag</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">genkey</span>(<span class="params">l</span>):</span><br><span class="line">    <span class="keyword">return</span> random.getrandbits(l)</span><br><span class="line"><span class="comment"># 求iv  去除掉收尾指定字符串</span></span><br><span class="line">iv = flag.strip(<span class="string">b&#x27;flag&#123;&#x27;</span>).strip(<span class="string">b&#x27;&#125;&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">key = <span class="string">&#x27;&#x27;</span>.join([random.choice(string.ascii_letters+string.digits) <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(<span class="number">16</span>)])</span><br><span class="line">LENGTH = <span class="built_in">len</span>(key)</span><br><span class="line"><span class="comment"># 16字节  所以会使用16个字符或长度为16的字符串做密码</span></span><br><span class="line"><span class="keyword">assert</span> LENGTH == <span class="number">16</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#  32字节 且为4个字符(32bit)的重复  32bit*8</span></span><br><span class="line"><span class="comment"># 每个字节由 2个十六进制字符表示 所以有 32*2=64个十六机制字符</span></span><br><span class="line">hint = os.urandom(<span class="number">4</span>) * <span class="number">8</span></span><br><span class="line"><span class="built_in">print</span>(bytes_to_long(hint)^bytes_to_long(key))</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 64 / 16 =4</span></span><br><span class="line">msg = <span class="string">b&#x27;Welcome, ctfer. Dont try too hard, its no use. Have a good day!!&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encrypto</span>(<span class="params">message</span>):</span><br><span class="line">    aes = AES.new(key,AES.MODE_CBC,iv)</span><br><span class="line">    <span class="keyword">return</span> aes.encrypt(message)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 对msg AES加密后 转十六进制后 输出后32位</span></span><br><span class="line"><span class="built_in">print</span>(binascii.hexlify(encrypto(msg))[-<span class="number">32</span>:])</span><br><span class="line"> </span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">99748265546679089946917295913637945222843938798184123305418691873367322323659</span></span><br><span class="line"><span class="string">bc03f3ac4ff8064acbcfaf0b0bf2ba7b</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<p>题目分析：</p>
<ol>
<li>
<p>已知 key 长度为 16 位，hint 为 32 字节 且为 4 个字节的重复 (32bit*8)</p>
</li>
<li>
<p>已知明文 message 64 位</p>
</li>
</ol>
<p>AES-CBC 解密流程：</p>
<p>enc为密文分组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">msg [0] =decrypt(enc1,key)^iv </span><br><span class="line">msg [1] =decrypt(enc2,key)^enc1 </span><br><span class="line">msg [2] =decrypt(enc3,key)^enc2 </span><br><span class="line">msg [3] =decrypt(enc4,key)^enc3 </span><br><span class="line">msg = msg [0]+msg [1]+msg [2]+msg [3]</span><br><span class="line"></span><br><span class="line">iv = msg[0] ^ decrypt(enc1,key) </span><br><span class="line">enc1 = msg[1] ^ decrypt(enc2,key) </span><br><span class="line">enc2 = msg[2] ^ decrypt(enc3,key) </span><br><span class="line">enc3 = msg[3] ^ decrypt(enc4,key)</span><br></pre></td></tr></table></figure>
<p>目前我们已知</p>
<p><code>hint^key=xxx</code>，因此<code>key=xxx^hint</code></p>
<p>明文msg即<code>msg[0],msg[1],msg[2],msg[3]</code></p>
<p>密文后32位bit即enc4</p>
<p>因此可以通过<code>enc3 = msg[3] ^ decrypt(enc4,key)</code>逆向求解出enc3，2，1，iv(flag)</p>
<p>首先可以看到hint是32位的 而key只有16位 并且hint是4位重复8次 那么就可以就出key</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"><span class="keyword">import</span> binascii, sys</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.strxor <span class="keyword">import</span> strxor</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"> </span><br><span class="line"><span class="comment"># -----------get key---------</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># tmp = hint ^ key -&gt; key = tmp ^ hint</span></span><br><span class="line">tmp = <span class="number">99748265546679089946917295913637945222843938798184123305418691873367322323659</span></span><br><span class="line"><span class="comment"># hint为32字节 key为16字节  所以异或后 tmp高位就是 hint的高位</span></span><br><span class="line"><span class="comment"># [2:10] 前面有0x 所以从第二位开始取8位</span></span><br><span class="line"><span class="comment"># 32字节 64个十六进制字符</span></span><br><span class="line">hint = <span class="built_in">int</span>(<span class="built_in">str</span>(<span class="built_in">hex</span>(tmp))[<span class="number">2</span>:<span class="number">10</span>] * <span class="number">8</span>, <span class="number">16</span>)</span><br><span class="line">key = long_to_bytes(tmp ^ hint)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># ----------get iv-----------</span></span><br><span class="line">msg = <span class="string">b&#x27;Welcome, ctfer. Dont try too hard, its no use. Have a good day!!&#x27;</span></span><br><span class="line">msgs = [msg[ii:(ii + <span class="number">16</span>)] <span class="keyword">for</span> ii <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(msg), <span class="number">16</span>)]</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(msgs)</span><br><span class="line"><span class="comment"># [b&#x27;Welcome, ctfer. &#x27;, b&#x27;Dont try too har&#x27;, b&#x27;d, its no use. H&#x27;, b&#x27;ave a good day!!&#x27;]</span></span><br><span class="line"> </span><br><span class="line">msgs.reverse()</span><br><span class="line"><span class="comment"># msg[3] msg[2] msg[1] msg[0]</span></span><br><span class="line"><span class="comment"># [b&#x27;ave a good day!!&#x27;, b&#x27;d, its no use. H&#x27;, b&#x27;Dont try too har&#x27;, b&#x27;Welcome, ctfer. &#x27;]</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">IV = binascii.unhexlify(<span class="string">&#x27;bc03f3ac4ff8064acbcfaf0b0bf2ba7b&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># iv = msg[0] ^ decrypt(enc1,key)</span></span><br><span class="line"><span class="comment"># enc1 = msg[1] ^ decrypt(enc2,key)</span></span><br><span class="line"><span class="comment"># enc2 = msg[2] ^ decrypt(enc3,key)</span></span><br><span class="line"><span class="comment"># enc3 = msg[3] ^ decrypt(enc4,key)</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decry</span>(<span class="params">key, IV, ms</span>):</span><br><span class="line">    aes = AES.new(key, AES.MODE_ECB)</span><br><span class="line">    <span class="keyword">return</span> strxor(aes.decrypt(IV), ms)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> ms <span class="keyword">in</span> msgs:</span><br><span class="line">    IV = decry(key, IV, ms)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">b&#x27;flag&#123;&#x27;</span> + IV + <span class="string">b&#x27;&#125;&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="aes-2"><a class="markdownIt-Anchor" href="#aes-2"></a> aes</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag</span><br><span class="line"> </span><br><span class="line"><span class="keyword">assert</span> flag[:<span class="number">5</span>] == <span class="string">&quot;flag&#123;&quot;</span> <span class="keyword">and</span> flag[-<span class="number">1</span>:] == <span class="string">&quot;&#125;&quot;</span></span><br><span class="line"> </span><br><span class="line">key = <span class="string">b&quot;J1fx2g1jDak1c***&quot;</span></span><br><span class="line">l = <span class="built_in">len</span>(key)</span><br><span class="line"></span><br><span class="line">message = <span class="string">b&quot;I have had my invitation to this world&#x27;s festival, and thus my life has been blessed&quot;</span> + binascii.unhexlify(hashlib.sha256(key).hexdigest())[:<span class="number">10</span>]</span><br><span class="line"></span><br><span class="line">iv = flag[<span class="number">5</span>:-<span class="number">1</span>]</span><br><span class="line">message = message + <span class="built_in">bytes</span>((l - <span class="built_in">len</span>(message) % l) * <span class="built_in">chr</span>(l - <span class="built_in">len</span>(message) % l), encoding = <span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">aes = AES.new(key, AES.MODE_CBC, iv)</span><br><span class="line"><span class="built_in">print</span>(binascii.hexlify(aes.encrypt(message)))</span><br><span class="line"><span class="comment">#******************************************************************************************************************************************************6ece036e495d363b647d7f2749c4c2f3dd78f8637b</span></span><br></pre></td></tr></table></figure>
<p>题目分析：</p>
<p>1.key 后三位未知 可爆破</p>
<p>2.明文 message 分 3 部分 第一部分明文已知，中间部分 10 个十六进制字符 后部分为 2 个 0x02 共 192 个十六进制字符</p>
<p>3.iv = flag [5:-1] 即 flag {iv} 求出 iv 即 flag</p>
<p>4.已知明文后 21 字节 根据分组 每组 16 字节 所以已知最后一块明文 及 倒数第二块后 5 字节明文</p>
<p><img src="../images/17.png" alt="img" /></p>
<p>在 CBC 中 与 ECB 相比 多的部分为 IV 异或一步</p>
<p><strong>密文 ^ key (AES_ECB) ^ IV → 明文</strong></p>
<p>最后一块的明文已知，key 可通过爆破后三位</p>
<p>最后一块的密文为 <code>b&quot;ssed&quot; + binascii.unhexlify (hashlib.sha256 (key).hexdigest ())[:10] + bytes ((l - len (message) % l) * chr (l - len (message) % l)</code></p>
<p>如果 key 已知 则密文也就是已知的</p>
<p>我们还知道倒数第二块中的后 5 个字节 可以作为最后一次加密的 IV 的一部分进行校验，如果结果中包含 已知的 5 个字节，则说明 key 正确。</p>
<p><code>IV = 明文 ^ (密文 ^ key)</code></p>
<p>求得 key 后 可进而推出 IV 即 flag</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Plaintext[0] = Ciphertext[0] ^ key ^ IV</span><br><span class="line"></span><br><span class="line">Plaintext[1] = Ciphertext[1] ^ key ^ Ciphertext[0]</span><br><span class="line"></span><br><span class="line">Plaintext[2] = Ciphertext[2] ^ key ^ Ciphertext[1]</span><br></pre></td></tr></table></figure>
<p>知道最后一个明文 密文 key 以此反复推出 IV</p>
<p>POC:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 1. 生成key字典</span></span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"> </span><br><span class="line">dic = string.printable[:<span class="number">62</span>]</span><br><span class="line"><span class="comment"># print(dic)</span></span><br><span class="line"><span class="comment"># 0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;key_table.txt&#x27;</span>,<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> dic:</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> dic:</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> dic:</span><br><span class="line">                key = <span class="string">b&quot;J1fx2g1jDak1c&quot;</span>+i.encode()+j.encode()+k.encode()</span><br><span class="line">                file.write(key+<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">file.close()</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 2.爆破key</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">xor</span>(<span class="params">m: <span class="built_in">bytes</span>, c: <span class="built_in">bytes</span></span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bytes</span>([i ^ j <span class="keyword">for</span> i, j <span class="keyword">in</span> <span class="built_in">zip</span>(m, c)])</span><br><span class="line"> </span><br><span class="line">enc = binascii.unhexlify(<span class="string">&#x27;5d363b647d7f2749c4c2f3dd78f8637b&#x27;</span>)</span><br><span class="line">five_part = binascii.unhexlify(<span class="string">b&quot;6ece036e49&quot;</span>)</span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;key_table.txt&quot;</span>,<span class="string">&quot;rb+&quot;</span>)</span><br><span class="line">pbar = tqdm(<span class="built_in">range</span>(<span class="number">238328</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> f:</span><br><span class="line">    key = i[:<span class="number">16</span>]</span><br><span class="line">    aes = AES.new(key, AES.MODE_ECB)</span><br><span class="line">    dec = aes.decrypt(enc)</span><br><span class="line">    <span class="comment"># 最后一块 16个字节 4+10+2</span></span><br><span class="line">    m = <span class="string">b&quot;ssed&quot;</span> +binascii.unhexlify(hashlib.sha256(key).hexdigest())[:<span class="number">10</span>]+<span class="string">b&#x27;\x02\x02&#x27;</span></span><br><span class="line">    xor_result = xor(m,dec)</span><br><span class="line">    pbar.update(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> five_part <span class="keyword">in</span> xor_result:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[+] key:&quot;</span>,key)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">f.close()</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 3.求IV</span></span><br><span class="line">l = <span class="built_in">len</span>(key)</span><br><span class="line"><span class="comment"># 192位</span></span><br><span class="line">message = <span class="string">b&quot;I have had my invitation to this world&#x27;s festival, and thus my life has been blessed&quot;</span> + binascii.unhexlify(hashlib.sha256(key).hexdigest())[:<span class="number">10</span>]</span><br><span class="line">message = message + <span class="built_in">bytes</span>((l - <span class="built_in">len</span>(message) % l) * <span class="built_in">chr</span>(l - <span class="built_in">len</span>(message) % l), encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(message),<span class="number">16</span>):</span><br><span class="line">    aes_ecb = AES.new(key,AES.MODE_ECB)</span><br><span class="line">    dec_c = aes_ecb.decrypt(enc)</span><br><span class="line">    enc = xor(message[<span class="built_in">len</span>(message)-i-<span class="number">16</span>:<span class="built_in">len</span>(message)-i],dec_c)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">b&#x27;flag&#123;&#x27;</span>+enc+<span class="string">b&#x27;&#125;&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment">#[+] key: b&#x27;J1fx2g1jDak1c7s4&#x27;</span></span><br><span class="line"><span class="comment">#b&#x27;flag&#123;\xd71\x8e\xa3r[3\x7f,&amp;\x05n\xce\x03nI&#125;&#x27;</span></span><br><span class="line"><span class="comment">#b&#x27;flag&#123;0\x07S\xbf^\xd9\x1d\xd3\xfcT\xf4I\xa6\x9b\xf3\xa0&#125;&#x27;</span></span><br><span class="line"><span class="comment">#b&#x27;flag&#123;\xc6\xd6Tc\xb6\x08\x9d\xa9H4\xa1Z\xfb\xeb\x08\x8f&#125;&#x27;</span></span><br><span class="line"><span class="comment">#b&#x27;flag&#123;\xb1 \t8\x0b\x9b\x18d\xa48\xf2;\r\xb1 \xc4&#125;&#x27;</span></span><br><span class="line"><span class="comment">#b&#x27;flag&#123;\x8c\xf3\xfa\xce\x93fB\xb9\xb2\xad\x01\x9d\x1a6\x80\x11&#125;&#x27;</span></span><br><span class="line"><span class="comment">#b&#x27;flag&#123;welcome_1234_igd&#125;&#x27;</span></span><br></pre></td></tr></table></figure>
<h4 id="moectf-ez_cbc"><a class="markdownIt-Anchor" href="#moectf-ez_cbc"></a> moectf ez_cbc</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag</span><br><span class="line">  </span><br><span class="line">IV = bytes_to_long(<span class="string">b&#x27;cbc!&#x27;</span>)<span class="comment"># 初始化向量，转换为长整型</span></span><br><span class="line">K = random.randrange(<span class="number">1</span>,<span class="number">1</span>&lt;&lt;<span class="number">30</span>)<span class="comment"># 随机密钥，范围1到2^30</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">assert</span> flag[:<span class="number">7</span>] == <span class="string">b&#x27;moectf&#123;&#x27;</span></span><br><span class="line"><span class="keyword">assert</span> flag[-<span class="number">1</span>:] == <span class="string">b&#x27;&#125;&#x27;</span></span><br><span class="line">  </span><br><span class="line">block_length = <span class="number">4</span></span><br><span class="line">flag = flag + ((block_length - <span class="built_in">len</span>(flag) % block_length) % block_length) * <span class="string">b&#x27;\x00&#x27;</span></span><br><span class="line">plain_block = [flag[block_length * i: block_length * (i + <span class="number">1</span>)] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(flag) // block_length)]</span><br><span class="line">  </span><br><span class="line">c = []</span><br><span class="line">c0 = (IV ^ bytes_to_long(plain_block[<span class="number">0</span>])) ^ K   <span class="comment"># 加密第一个块</span></span><br><span class="line">c.append(c0)</span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(plain_block)-<span class="number">1</span>):</span><br><span class="line">    c.append(c[i] ^ bytes_to_long(plain_block[i+<span class="number">1</span>]) ^ K)</span><br><span class="line">  </span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line">  </span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">[748044282, 2053864743, 734492413, 675117672, 1691099828, 1729574447, 1691102180, 657669994, 1741780405, 842228028, 1909206003, 1797919307]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment">#  flag 为  moectf&#123;flag&#125;</span></span><br></pre></td></tr></table></figure>
<p>题目分析：</p>
<ol>
<li>IV 已知，flag 部分已知 moectg {}</li>
<li>block_length =4 且 已知 flag 前四位为 moec</li>
</ol>
<p>所以可以通过此去恢复 K</p>
<p>密文块 = 明文块 ^ iv ^ K</p>
<p>明文块 = 密文块 ^ iv ^ K</p>
<p>K = 密文块 ^ 明文块 ^ iv</p>
<p>K = IV ^ bytes_to_long(plain_block[0]) ^ c[0]</p>
<ol start="3">
<li>求得 K 后 进而求得 m， m = K ^ c [i] ^ c [i+1]</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># from Crypto.Cipher import AES</span></span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> bytes_to_long, long_to_bytes</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line">c=[<span class="number">748044282</span>, <span class="number">2053864743</span>, <span class="number">734492413</span>, <span class="number">675117672</span>, <span class="number">1691099828</span>, <span class="number">1729574447</span>, <span class="number">1691102180</span>, <span class="number">657669994</span>, <span class="number">1741780405</span>, <span class="number">842228028</span>, <span class="number">1909206003</span>, <span class="number">1797919307</span>]</span><br><span class="line">IV = bytes_to_long(<span class="string">b&#x27;cbc!&#x27;</span>)</span><br><span class="line">flag = <span class="string">b&#x27;moec&#x27;</span></span><br><span class="line">K=(IV^bytes_to_long(flag))^c[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;K:&quot;</span>, K)</span><br><span class="line">m=<span class="string">b&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(c)-<span class="number">1</span>):</span><br><span class="line">    m+=long_to_bytes(c[i]^c[i+<span class="number">1</span>]^K)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;m:&quot;</span>, m)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">b&#x27;moec&#x27;</span>+m)</span><br><span class="line"><span class="comment">#K: 580598200</span></span><br><span class="line"><span class="comment">#m: b&#x27;tf&#123;es72b!a5-njad!@-#!@$sad-6bysgwy-1adsw8&#125;\x00\x00&#x27;</span></span><br><span class="line"><span class="comment">#b&#x27;moectf&#123;es72b!a5-njad!@-#!@$sad-6bysgwy-1adsw8&#125;\x00\x00&#x27;</span></span><br></pre></td></tr></table></figure>
<h4 id="moectf-ez_chain"><a class="markdownIt-Anchor" href="#moectf-ez_chain"></a> moectf ez_chain</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;key.txt&quot;</span>, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> fs:</span><br><span class="line">    key = <span class="built_in">int</span>(fs.read().strip())</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;flag.txt&quot;</span>, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> fs:</span><br><span class="line">    flag = fs.read().strip()</span><br><span class="line"><span class="keyword">assert</span> <span class="built_in">len</span>(flag) == <span class="number">72</span>   <span class="comment"># 确保flag长度为72字节</span></span><br><span class="line"> </span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line"> </span><br><span class="line">base = bytes_to_long(<span class="string">b&quot;koito&quot;</span>)  <span class="comment"># 特殊基数&quot;koito&quot;的数值表示</span></span><br><span class="line">iv = <span class="number">3735927943</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">blockize</span>(<span class="params">long</span>):</span><br><span class="line">    out = []</span><br><span class="line">    <span class="keyword">while</span> long &gt; <span class="number">0</span>:</span><br><span class="line">        out.append(long % base)  <span class="comment"># 取base为模</span></span><br><span class="line">        long //= base  <span class="comment"># 整除base</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>(<span class="built_in">reversed</span>(out))  <span class="comment"># 反转列表</span></span><br><span class="line"> </span><br><span class="line">blocks = blockize(m)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encrypt_block_cbc</span>(<span class="params">blocks, iv, key</span>):</span><br><span class="line">    encrypted = [iv]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(blocks)):</span><br><span class="line">        encrypted.append(blocks[i] ^ encrypted[i] ^ key)</span><br><span class="line">    <span class="keyword">return</span> encrypted[<span class="number">1</span>:]</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(encrypt_block_cbc(blocks, iv, key))</span><br><span class="line"><span class="comment"># [8490961288, 122685644196, 349851982069, 319462619019, 74697733110, 43107579733, 465430019828, 178715374673, 425695308534, 164022852989, 435966065649, 222907886694, 420391941825, 173833246025, 329708930734]</span></span><br></pre></td></tr></table></figure>
<p>这个题有点东西</p>
<p><code>blockize</code>函数相当于是把传入的<code>long</code>用<code>base</code>进制表示，最后把<code>out</code>逆序返回，所以返回的列表中存放的是<code>long</code>的高位到低位(对于base进制而言的高位低位)。</p>
<p>flag 72 位，m 为 flag 需求项</p>
<p>需要写 2 个解密函数 decrypt_block_cbc 和 deblockize</p>
<p><code>K = 密文块 ^ 明文块 ^ iv</code></p>
<p>重点是求key</p>
<p>flag的长度与格式是固定的，而密钥则是通过对<code>bytes_to_long(flag)</code>进行一系列模运算得到的。从理论上说，我们只需利用flag的这些已知信息，便可以求出key。</p>
<p>经过发现</p>
<p>flag1 = b’moectf{???}’</p>
<p>flag2 = b’moectf{!!!}'得到的key的值是相同的。这验证了我们的猜想。</p>
<p>因此我们假设flag为<code>b&quot;moectf&#123;&quot; + b&quot;0&quot;*64 + b&quot;&#125;</code>，然后照样求得出key</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line">base = bytes_to_long(<span class="string">b&quot;koito&quot;</span>)</span><br><span class="line">iv = <span class="number">3735927943</span></span><br><span class="line"> </span><br><span class="line">blocks = [<span class="number">8490961288</span>, <span class="number">122685644196</span>, <span class="number">349851982069</span>, <span class="number">319462619019</span>, <span class="number">74697733110</span>, <span class="number">43107579733</span>, <span class="number">465430019828</span>, <span class="number">178715374673</span>, <span class="number">425695308534</span>, <span class="number">164022852989</span>, <span class="number">435966065649</span>, <span class="number">222907886694</span>, <span class="number">420391941825</span>, <span class="number">173833246025</span>, <span class="number">329708930734</span>]</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">blockize</span>(<span class="params">long</span>):</span><br><span class="line">    out = []</span><br><span class="line">    <span class="keyword">while</span> long &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># 取余数 存入 out</span></span><br><span class="line">        out.append(long % base)</span><br><span class="line">        long //= base</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>(<span class="built_in">reversed</span>(out))</span><br><span class="line"> </span><br><span class="line"><span class="comment">#将块重新组合为大整数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">deblockize</span>(<span class="params">blocks</span>):</span><br><span class="line">    out = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> block <span class="keyword">in</span> blocks:</span><br><span class="line">        out = out * base + block</span><br><span class="line">    <span class="keyword">return</span> out</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encrypt_block_cbc</span>(<span class="params">blocks, iv, key</span>):</span><br><span class="line">    encrypted = [iv]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(blocks)):</span><br><span class="line">        encrypted.append(blocks[i] ^ encrypted[i] ^ key)</span><br><span class="line">    <span class="keyword">return</span> encrypted[<span class="number">1</span>:]</span><br><span class="line"><span class="comment"># blocks[0] ^ iv ^ key =  flag[0]</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decrypt_block_cbc</span>(<span class="params">blocks, iv, key</span>):</span><br><span class="line">    <span class="comment"># iv 初始化向量</span></span><br><span class="line">    encrypted = [iv, *blocks]</span><br><span class="line">    decrypted = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(blocks)):</span><br><span class="line">        decrypted.append(encrypted[i] ^ encrypted[i + <span class="number">1</span>] ^ key)</span><br><span class="line">    <span class="keyword">return</span> decrypted</span><br><span class="line"> </span><br><span class="line"><span class="comment">#  flag = moectf&#123;xxx&#125;</span></span><br><span class="line"><span class="comment">#  72个字符  其中 moectf 6 &#123;&#125; 2  72-2-6=64个</span></span><br><span class="line"><span class="comment">#  flag[0] = blocks[0] ^ key ^ iv</span></span><br><span class="line"><span class="comment">#  key = iv ^ blocks[0] ^ flag[0]</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;flag[0]:&quot;</span>,blockize(bytes_to_long(<span class="string">b&quot;moectf&#123;&quot;</span> + <span class="string">b&quot;0&quot;</span>*<span class="number">64</span> + <span class="string">b&quot;&#125;&quot;</span>))[<span class="number">0</span>] )</span><br><span class="line"><span class="comment"># print(blockize(bytes_to_long(b&quot;moectf&#123;&quot; + b&quot;0&quot;*64 + b&quot;&#125;&quot;)))</span></span><br><span class="line">key = blockize(bytes_to_long(<span class="string">b&quot;moectf&#123;&quot;</span> + <span class="string">b&quot;0&quot;</span>*<span class="number">64</span> + <span class="string">b&quot;&#125;&quot;</span>))[<span class="number">0</span>] ^ iv ^ blocks[<span class="number">0</span>]</span><br><span class="line">m = long_to_bytes(deblockize(decrypt_block_cbc(blocks, iv, key)))</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;key:&quot;</span>,key)</span><br><span class="line"><span class="built_in">print</span>(m)</span><br><span class="line"></span><br><span class="line"><span class="comment">#flag[0]: 5329712293</span></span><br><span class="line"><span class="comment">#key: 421036458</span></span><br><span class="line"><span class="comment">#b&#x27;moectf&#123;thE_c6c_Is_not_so_hard_9ifxi9i!JGofMJ36D9cPMxroif6!M6oSMuliPPcA3&#125;&#x27;</span></span><br></pre></td></tr></table></figure>
<h4 id="afctf-myowncbc"><a class="markdownIt-Anchor" href="#afctf-myowncbc"></a> Afctf MyOwnCBC</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python2.7</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">from</span> Crypto.Random <span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">MyOwnCBC</span>(<span class="params">key, plain</span>):</span><br><span class="line">  <span class="comment"># key 32位  但key未知</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(key)!=<span class="number">32</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;error!&quot;</span></span><br><span class="line">	cipher_txt = <span class="string">b&quot;&quot;</span></span><br><span class="line">	cipher_arr = []</span><br><span class="line">	<span class="comment"># 自定义加密 ECB </span></span><br><span class="line">	cipher = AES.new(key, AES.MODE_ECB, <span class="string">&quot;&quot;</span>)</span><br><span class="line">	<span class="comment"># 等价于 cipher = AES.new(key, AES.MODE_ECB)</span></span><br><span class="line">	plain = [plain[i:i+<span class="number">32</span>] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(plain), <span class="number">32</span>)]</span><br><span class="line">  	<span class="comment"># 32位(16字节)为一组 然后进行ECB加密</span></span><br><span class="line">	<span class="built_in">print</span> plain</span><br><span class="line">  	<span class="comment"># 加密后 存入密文数组 	</span></span><br><span class="line">	cipher_arr.append(cipher.encrypt(plain[<span class="number">0</span>]))</span><br><span class="line">	cipher_txt += cipher_arr[<span class="number">0</span>]</span><br><span class="line">	</span><br><span class="line">  	<span class="comment"># cipher_txt = [cipher_arr[i]] 	</span></span><br><span class="line">  	<span class="comment"># 上一个密文 作为 下一个密文的密钥key进行加密</span></span><br><span class="line">  	<span class="comment"># key0 为第一组的密文 即 key0 = cipher[0:32]</span></span><br><span class="line">	<span class="comment"># 然后以 前一个 cipher_arr[i-1]作为key 进行ecb加密</span></span><br><span class="line">	<span class="comment">#   cipher_arr[i-1] ^ cipher_arr[i]</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(plain)):</span><br><span class="line">		cipher = AES.new(cipher_arr[i-<span class="number">1</span>], AES.MODE_ECB, <span class="string">&quot;&quot;</span>)</span><br><span class="line">		cipher_arr.append(cipher.encrypt(plain[i]))</span><br><span class="line">		cipher_txt += cipher_arr[i]</span><br><span class="line">	<span class="keyword">return</span> cipher_txt</span><br><span class="line">	</span><br><span class="line"><span class="comment"># 生成256位的随机整数	</span></span><br><span class="line">key = random.getrandbits(<span class="number">256</span>)</span><br><span class="line">key = long_to_bytes(key)</span><br><span class="line"></span><br><span class="line">s = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;flag.txt&quot;</span>,<span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">	s = f.read()</span><br><span class="line">	f.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 密文写入到flag_cipher 是已知项</span></span><br><span class="line"><span class="comment"># 长度为 6A0h = 1696</span></span><br><span class="line"><span class="comment"># 1696 / 32 = 53组</span></span><br><span class="line"><span class="comment"># 由于上一个密文作为key 参与下一次密文加密 所以长度都相同</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;flag_cipher&quot;</span>,<span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">	f.write(MyOwnCBC(key, s))</span><br><span class="line">	f.close()</span><br></pre></td></tr></table></figure>
<p>第一次密文 作为密钥 key0 参与 ECB 加密 key = cipher [:32]</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;flag_cipher&quot;</span>, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">    <span class="comment"># print(len(fp.read()))</span></span><br><span class="line">    cipher = fp.read()</span><br><span class="line">    fp.close()</span><br><span class="line"></span><br><span class="line">key0 = cipher[:<span class="number">32</span>]</span><br><span class="line"><span class="built_in">print</span>(key0)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">MyOwnCBC</span>(<span class="params">key0,cipher</span>):</span><br><span class="line">    cipher = [cipher[i:i + <span class="number">32</span>] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(cipher), <span class="number">32</span>)]</span><br><span class="line">    m = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">    tmpkey = key0</span><br><span class="line">	<span class="comment"># 上一次的密文作为key参与下一次ECB</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(cipher)):</span><br><span class="line">        aes = AES.new(tmpkey,AES.MODE_ECB)</span><br><span class="line">        m += aes.decrypt(cipher[i])</span><br><span class="line">        tmpkey = cipher[i]</span><br><span class="line">    <span class="keyword">return</span> m</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(MyOwnCBC(key0,cipher))</span><br><span class="line"><span class="comment">#b&#x27;\xe5\xdf\x94sJ\xc2\xcd\x04\xeb\xb7\xcf\x05(\xbe\x98\\\xe9\xc3^\x1f!\xfb\xea6\xdac\x1f\xfe\x901\xbb\x13&#x27;</span></span><br><span class="line"><span class="comment">#b&quot;mode of operation is an algorithm that uses a block cipher to provide an information service such as confidentiality or authenticity. A block cipher by itself is only suitable for the secure cryptographic transformation (encryption or decryption) of one fixed-length group of bits called a block. A mode of operation describes how to repeatedly apply a cipher&#x27;s single-block operation to securely transform amounts of data larger than a block.\n\nMost modes require a unique binary sequence, often called an initialization vector (IV), for each encryption operation. The IV has to be non-repeating and, for some modes, random as well. The initialization vector is used to ensure distinct ciphertexts are produced even when the same plaintext is encrypted multiple times independently with the same key. Block ciphers have one or more block size(s), but during transformation the block size is always fixed. Block cipher modes operate on whole blocks and require that the last part of the data be padded to a full block if it is smaller than the current block size. There are, however, modes that do not require padding because they effectively use a block cipher as a stream cipher.\n\nHistorically, encryption modes have been studied extensively in regard to their error propagation properties under various scenarios of data modification. Later development regarded integrity protection as an entirely separate cryptographic goal. Some modern modes of operation combine confidentiality and authenticity in an efficient way, and are known as authenticated encryption modes.\n\nAh you found it~ afctf&#123;Don&#x27;t_be_fooled_by_yourself&#125;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="des"><a class="markdownIt-Anchor" href="#des"></a> DES</h2>
<h3 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h3>
<p>DES使用<strong>56位的密钥</strong>和<strong>64位的明文块</strong>进行加密。<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=DES%E7%AE%97%E6%B3%95&amp;spm=1001.2101.3001.7020">DES算法</a>的分组大小是64位，因此，如果需要加密的明文长度<strong>不足64位</strong>，需要进行<strong>填充</strong>；如果明文长度<strong>超过64位</strong>，则需要使用分组模式进行<strong>分组加密</strong>。</p>
<p>虽然DES算法的分组大小是64位，但是由于DES算法的密钥长度只有56位，因此DES算法存在着弱点，容易受到暴力破解和差分攻击等攻击手段的威胁。</p>
<ul>
<li>输入 64 位。</li>
<li>输出 64 位。</li>
<li>密钥 64 位，使用 64 位密钥中的 56 位，剩余的 8 位要么丢弃，要么作为奇偶校验位。</li>
<li>Feistel 迭代结构
<ul>
<li>明文经过 16 轮迭代得到密文。</li>
<li>密文经过类似的 16 轮迭代得到明文。</li>
</ul>
</li>
</ul>
<h3 id="feistel-网络"><a class="markdownIt-Anchor" href="#feistel-网络"></a> Feistel 网络</h3>
<p>Feistel cipher 也叫做 Luby–Rackoff</p>
<p>分组密码 DES 就使用的该方法，加密和解密操作相似，需要进行多轮的加解密操作。</p>
<p>在 Feistel 网络中 加密的各个步骤称为 <strong>轮</strong> ， <strong>整个加密过程就是进行若干轮的循环</strong>。</p>
<p><img src="../images/1-175482370573918.png" alt="img" /></p>
<p>一轮过程具体如下：</p>
<ol>
<li>
<p>将输入的 64bit 分成两组 32bit【记作左侧、右侧】</p>
</li>
<li>
<p>将右侧数据直接发送到右侧输出中</p>
</li>
<li>
<p>将右侧数据发送给轮函数，轮函数通过子密钥和右侧数据 进行运算处理生成加密的比特序列</p>
</li>
<li>
<p>将处理后的数据与左侧数据进行 XOR，将加密结果作为左侧输出数据</p>
</li>
</ol>
<p>从上图可看出，右侧数据并没有进行加密，因此需要用<strong>不同的子密钥</strong>进行<strong>若干轮处理</strong>，并将<strong>每次处理前左右侧数据对调</strong>。【最后一轮中不再进行左右侧数据对调】</p>
<h3 id="des加密流程"><a class="markdownIt-Anchor" href="#des加密流程"></a> DES加密流程</h3>
<p>DES 加密流程如下图所示：</p>
<p><img src="../images/2-175482389788521.png" alt="img" /></p>
<p>简要概括为：</p>
<ol>
<li>
<p>将明文进行 <strong>初始置换 IP</strong></p>
</li>
<li>
<p>进行 <strong>16 轮加密处理</strong></p>
</li>
<li>
<p>进行 <strong>逆初始置换 IP-1</strong> ，输出密文</p>
</li>
</ol>
<p>------------------------------------------------------</p>
<ul>
<li>明文处理阶段</li>
</ul>
<p>明文初始置换【64 位】 置换后明文分 2 组【32 位】</p>
<ul>
<li>子密钥生成阶段</li>
<li>加密阶段</li>
<li>密文逆置换阶段</li>
</ul>
<p>将上述操作的密文进行逆置换得到最终密文</p>
<p>-----------------------------------------------------</p>
<p>具体流程如下：</p>
<h4 id="初始置换"><a class="markdownIt-Anchor" href="#初始置换"></a> 初始置换</h4>
<p>IP 置换 将输入的 64 位数据块重新组合，并分为 L0 R0 两组，每部分 32 位【实际分组中 前 32 位数据为 L 组 后 32 位数据位 R 组】</p>
<p>初始置换表如下：</p>
<p><img src="../images/3-175482448111324.png" alt="img" /></p>
<p>首先将 64 位明文数据 按从左到右，从上到下排列为 8x8 矩阵。</p>
<p>0 行 0 列出 58 表示将第 58 位上的数值置换到 0,0 处的值 总共需要置换 64 次得到最终结果。</p>
<h4 id="轮函数-f"><a class="markdownIt-Anchor" href="#轮函数-f"></a> 轮函数 F</h4>
<p>DES 中</p>
<p><img src="../images/4-175482456689627.png" alt="img" /></p>
<p>可简单概括为如下步骤：</p>
<ol>
<li>
<p>将 32 位 R 组进行拓展置换，生成 48 位数据；</p>
</li>
<li>
<p>将置换生成的 48 位数据与 48 位的子密钥进行异或，得到 48 位运算结果；</p>
</li>
<li>
<p>将 48 位运算结果分成 8 组，每组 6 位，进行 s 盒置换得到 4 位的数据；</p>
</li>
<li>
<p>将 8 个 4bit 的数据合并得到 32 位数据；</p>
</li>
<li>
<p>将 32 位数据进行 P 置换 最终得到 32 位处理结果。</p>
</li>
</ol>
<h5 id="拓展置换"><a class="markdownIt-Anchor" href="#拓展置换"></a> 拓展置换</h5>
<p>通过拓展置换，将输入数据长度从 32 位【4x8】变为 48 位【6x8】，在两边分别加一列拓展的重复数据。</p>
<p><img src="../images/5-175482467513831.png" alt="img" /></p>
<h5 id="s-盒置换"><a class="markdownIt-Anchor" href="#s-盒置换"></a> S 盒置换</h5>
<p>在 s 盒置换之前需要将异或运算的结果进行分组【48 位】，从前往后分成 8 组，每组 6bit 数据，每组对应一个 S 盒表。【s1~s8 盒表内容如下】</p>
<p><img src="../images/6-175482467513933.png" alt="img" /></p>
<p><img src="../images/7-175482467513935.png" alt="img" /></p>
<p>都是由 4x16 矩阵构成，所以可以以 4bit 来表示。</p>
<p>在拓展置换后的数中，第一个 bit 称为 MSB，最后一 bit 称为为 LSB，第一个 bit 权重最高，中间 4bit 为原始数据，最后一个 bit 权重最低。</p>
<p>MSB 位和 LSB 位构成的二进制表示 s 盒中行号，中间原始数据的二进制表示列号</p>
<p><img src="../images/8-175482467513937.png" alt="img" /></p>
<h5 id="p-置换"><a class="markdownIt-Anchor" href="#p-置换"></a> P 置换</h5>
<p>P 置换和初始置换大似相同</p>
<p><img src="../images/9-175482467513940.png" alt="img" /></p>
<p>最终输出 32 位数据</p>
<h4 id="逆初始置换"><a class="markdownIt-Anchor" href="#逆初始置换"></a> 逆初始置换</h4>
<p>F 函数输出的 32 位数据 与 L [i] 组数据进行按位异或运算，得到 32 位运算结果，最后把结果赋值给 R [i+1]。R [i] 组 32 位数据会直接赋值给 L [i+1]【不做任何改变】</p>
<p>这样就完成了一轮 DES 算法。经过 16 轮处理后得到最后一组数据 L [16]、R [16]。</p>
<p>R[i+1] = L[i] ^ F(R[i],K[i])</p>
<p>L[i+1] = R[i]</p>
<p>R [16] 作为前 32 位数据，L [16] 作为后 32 位数据 合并得到 64 位数据，然后进行逆初始值置值处理【和初始置换相似】 最终得到加密的密文。</p>
<p><img src="../images/10.png" alt="img" /></p>
<h3 id="密钥生成"><a class="markdownIt-Anchor" href="#密钥生成"></a> 密钥生成</h3>
<p>输入密钥 64 位【实际 56 位，根据置换表得到密钥 28 位 x2】</p>
<p><img src="../images/11.png" alt="img" /></p>
<h4 id="pc-1-置换"><a class="markdownIt-Anchor" href="#pc-1-置换"></a> PC-1 置换</h4>
<p><img src="../images/12.png" alt="img" /></p>
<p>PC-1【PERMUTED CHOICE 1 】置换表是一个 7x8 矩阵，</p>
<p>前 28 位分为一组记作 C 组，后 28 位为另一组记作 D 组。</p>
<h4 id="左移处理"><a class="markdownIt-Anchor" href="#左移处理"></a> 左移处理</h4>
<p>当 i=1,2,9,16 轮时，C、D 两组向左移一位，其他轮 C、D 两组向左移 2 位。</p>
<p><img src="../images/13-175482467513944.png" alt="img" /></p>
<h4 id="pc-2-置换"><a class="markdownIt-Anchor" href="#pc-2-置换"></a> PC-2 置换</h4>
<p>在进行 PC-2 置换前，将左移后的 C D 两组数据【28bit】合并，形成 56bit 的数据块，PC-2 置换表是一个 6x8 矩阵，经过 PC-2 置换后会变成一个 48bit 的子密钥。</p>
<p><img src="../images/14-175482467513830.png" alt="img" /></p>
<h2 id="cbc字节翻转"><a class="markdownIt-Anchor" href="#cbc字节翻转"></a> CBC字节翻转</h2>
<p>**Plaintext：**明文数据</p>
<p>**IV：**初始向量</p>
<p>**Key：**分组加密使用的密钥</p>
<p>**Ciphertext：**密文数据</p>
<p>每组解密时，先进行分组加密算法的解密，然后与<strong>前一组的密文</strong>进行异或才是最初的明文。</p>
<p>对于第一组则是与<strong>IV</strong>进行异或。</p>
<p>上一块密文用来产生下一块明文，如果改变上一块密文的一个字节，然后与下一个解密后的组块异或，就可以得到一个不同的明文。</p>
<p><img src="../images/CBC-example.png" alt="CBC" /></p>
<p><strong>字节翻转攻击：要把Plain2中的某一字节翻转为另一字节</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 获取普通用户的 Cookie（替换为实际 cookie）</span></span><br><span class="line">original_cookie = <span class="string">&quot;Lm/NsRCXQ6vrFDcclnufREw/txBSmvYS722VCmpFVtrG/IDVG+GuTETQdLYxCjIHk8ihEdsgg35P3lKWaHrF3sWl0bCwEpbkdMUHJmzdssyI7l9qnJx31PNT17eSV8m+&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 解码并拆分密文</span></span><br><span class="line">encrypted = base64.b64decode(original_cookie)</span><br><span class="line">iv = <span class="built_in">bytearray</span>(encrypted[:<span class="number">16</span>])</span><br><span class="line">ciphertext = encrypted[<span class="number">16</span>:]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 计算 name 字段的精确偏移（根据已知 JSON 结构）</span></span><br><span class="line">name_start = <span class="number">10</span>  <span class="comment"># &quot;m&quot; 的偏移位置（第 11 字节）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 定义翻转目标</span></span><br><span class="line">original_name = <span class="string">&quot;miaoa&quot;</span></span><br><span class="line">target_name = <span class="string">&quot;admin&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 执行位翻转攻击</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(target_name)):</span><br><span class="line">    <span class="comment"># 计算当前字符的异或差值</span></span><br><span class="line">    orig_char = <span class="built_in">ord</span>(original_name[i])</span><br><span class="line">    target_char = <span class="built_in">ord</span>(target_name[i])</span><br><span class="line">    xor_diff = orig_char ^ target_char</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 修改 IV 中对应的字节</span></span><br><span class="line">    iv[name_start + i] ^= xor_diff</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6. 生成攻击 Cookie</span></span><br><span class="line">modified_cookie = base64.b64encode(iv + ciphertext).decode()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 7. 验证攻击</span></span><br><span class="line">resp = requests.get(<span class="string">&quot;http://localhost:5000/home&quot;</span>,</span><br><span class="line">                    cookies=&#123;<span class="string">&quot;jwbcookie&quot;</span>: modified_cookie&#125;)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Admin Check:&quot;</span>, <span class="string">&quot;Welcome, admin&quot;</span> <span class="keyword">in</span> resp.text)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Cookie 为&quot;</span>, modified_cookie)</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      
      
      
      
      
      
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item" data-aos="zoom-in"><a class="article-tag-list-link" href="/tags/crypto/" rel="tag">crypto</a></li></ul>


    </footer>
  </div>
  
  <nav id="article-nav" data-aos="fade-up">
    
      <div class="article-nav-link-wrap article-nav-link-left">
        
          
          
            <img data-src="/images/126839103p0master1200.jpg" data-sizes="auto" alt="Crypto-算法&amp;题目" class="lazyload">
          
        
        <a href="/2025/08/10/Crypto-%E7%AE%97%E6%B3%95&%E9%A2%98%E7%9B%AE/"></a>
        <div class="article-nav-caption">前一篇</div>
        <h3 class="article-nav-title">
          
            Crypto-算法&amp;题目
          
        </h3>
      </div>
    
    
    <div class="article-nav-link-wrap article-nav-link-right">
      
        
        
          <img data-src="/images/background-2.jpg" data-sizes="auto" alt="[RCTF2019]calcalcalc" class="lazyload">
        
      
      <a href="/2025/06/20/%5BRCTF2019%5Dcalcalcalc/"></a>
      <div class="article-nav-caption">后一篇</div>
      <h3 class="article-nav-title">
        
          [RCTF2019]calcalcalc
        
      </h3>
    </div>
    
  </nav>


</article>






</section>
        </div>
        
        
        <footer id="footer">
  <div style="width: 100%; overflow: hidden">
    <div class="footer-line"></div>
  </div>
  <div id="footer-info">
    
    <div>
      <span class="icon-copyright"></span>
      2020-2025
      <span class="footer-info-sep rotate"></span>
      FuB0Y
    </div>
    
      <div>
        基于&nbsp;<a href="https://hexo.io/" rel="noopener external nofollow noreferrer" target="_blank">Hexo</a>&nbsp;
        Theme.<a href="https://github.com/D-Sketon/hexo-theme-reimu" rel="noopener external nofollow noreferrer" target="_blank">Reimu</a>
      </div>
    
    
      <div>
        <span class="icon-brush"></span>
        284k
        &nbsp;|&nbsp;
        <span class="icon-coffee"></span>
        20:48
      </div>
    
    
    
    
      <div>
        <span class="icon-eye"></span>
        <span id="busuanzi_container_site_pv">总访问量&nbsp;<span id="busuanzi_value_site_pv"></span></span>
        &nbsp;|&nbsp;
        <span class="icon-user"></span>
        <span id="busuanzi_container_site_uv">总访客量&nbsp;<span id="busuanzi_value_site_uv"></span></span>
      </div>
    
  </div>
</footer>

        
          <div class="sidebar-top">
            <div class="sidebar-top-taichi rotate"></div>
            <div class="arrow-up"></div>
          </div>
        
        <div id="mask" class="hide"></div>
      </div>
      <nav id="mobile-nav">
  <div class="sidebar-wrap">
    
      <div class="sidebar-toc-sidebar"><div class="sidebar-toc">
  <h3 class="toc-title">文章目录</h3>
  <div class="sidebar-toc-wrapper toc-div-class" >
      
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#aes"><span class="toc-number">1.</span> <span class="toc-text"> AES</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E4%B8%AA%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.</span> <span class="toc-text"> 三个基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%86%E9%92%A5"><span class="toc-number">1.1.1.</span> <span class="toc-text"> 密钥</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A1%AB%E5%85%85"><span class="toc-number">1.1.2.</span> <span class="toc-text"> 填充</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.1.3.</span> <span class="toc-text"> 模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ecb-%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.1.3.1.</span> <span class="toc-text"> ECB 模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#cbc-%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.1.3.2.</span> <span class="toc-text"> CBC 模式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#aes-%E5%8A%A0%E5%AF%86%E6%B5%81%E7%A8%8B"><span class="toc-number">1.2.</span> <span class="toc-text"> AES 加密流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#aes-ecb-%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.3.</span> <span class="toc-text"> AES-ECB 模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.3.1.</span> <span class="toc-text"> 代码示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#aes-cbc-%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.4.</span> <span class="toc-text"> AES-CBC 模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E5%AF%86%E8%BF%87%E7%A8%8B"><span class="toc-number">1.4.1.</span> <span class="toc-text"> 加密过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%AF%86%E8%BF%87%E7%A8%8B"><span class="toc-number">1.4.2.</span> <span class="toc-text"> 解密过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.4.3.</span> <span class="toc-text"> 代码实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98"><span class="toc-number">1.5.</span> <span class="toc-text"> 例题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#babyaes%E5%B7%B2%E7%9F%A5iv%E5%AF%86%E6%96%87%E5%AF%86%E9%92%A5"><span class="toc-number">1.5.1.</span> <span class="toc-text"> BabyAES（已知iv,密文,密钥）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2020-%E5%B9%B4%E7%AC%AC%E4%B8%89%E5%B1%8A%E5%AE%89%E6%B4%B5%E6%9D%AF-easyaes"><span class="toc-number">1.5.2.</span> <span class="toc-text"> [2020 年第三届安洵杯] easyaes</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#aes-2"><span class="toc-number">1.5.3.</span> <span class="toc-text"> aes</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#moectf-ez_cbc"><span class="toc-number">1.5.4.</span> <span class="toc-text"> moectf ez_cbc</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#moectf-ez_chain"><span class="toc-number">1.5.5.</span> <span class="toc-text"> moectf ez_chain</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#afctf-myowncbc"><span class="toc-number">1.5.6.</span> <span class="toc-text"> Afctf MyOwnCBC</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#des"><span class="toc-number">2.</span> <span class="toc-text"> DES</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">2.1.</span> <span class="toc-text"> 简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#feistel-%E7%BD%91%E7%BB%9C"><span class="toc-number">2.2.</span> <span class="toc-text"> Feistel 网络</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#des%E5%8A%A0%E5%AF%86%E6%B5%81%E7%A8%8B"><span class="toc-number">2.3.</span> <span class="toc-text"> DES加密流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E7%BD%AE%E6%8D%A2"><span class="toc-number">2.3.1.</span> <span class="toc-text"> 初始置换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AE%E5%87%BD%E6%95%B0-f"><span class="toc-number">2.3.2.</span> <span class="toc-text"> 轮函数 F</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8B%93%E5%B1%95%E7%BD%AE%E6%8D%A2"><span class="toc-number">2.3.2.1.</span> <span class="toc-text"> 拓展置换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#s-%E7%9B%92%E7%BD%AE%E6%8D%A2"><span class="toc-number">2.3.2.2.</span> <span class="toc-text"> S 盒置换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#p-%E7%BD%AE%E6%8D%A2"><span class="toc-number">2.3.2.3.</span> <span class="toc-text"> P 置换</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%86%E5%88%9D%E5%A7%8B%E7%BD%AE%E6%8D%A2"><span class="toc-number">2.3.3.</span> <span class="toc-text"> 逆初始置换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%86%E9%92%A5%E7%94%9F%E6%88%90"><span class="toc-number">2.4.</span> <span class="toc-text"> 密钥生成</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#pc-1-%E7%BD%AE%E6%8D%A2"><span class="toc-number">2.4.1.</span> <span class="toc-text"> PC-1 置换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A6%E7%A7%BB%E5%A4%84%E7%90%86"><span class="toc-number">2.4.2.</span> <span class="toc-text"> 左移处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pc-2-%E7%BD%AE%E6%8D%A2"><span class="toc-number">2.4.3.</span> <span class="toc-text"> PC-2 置换</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cbc%E5%AD%97%E8%8A%82%E7%BF%BB%E8%BD%AC"><span class="toc-number">3.</span> <span class="toc-text"> CBC字节翻转</span></a></li></ol>
      
  </div>
</div>
</div>
      <div class="sidebar-common-sidebar hidden"><div class="sidebar-author">
  <img data-src="/avatar/avatar.jpg" data-sizes="auto" alt="FuB0Y" class="lazyload">
  <div class="sidebar-author-name">FuB0Y</div>
  <div class="sidebar-description">世所谓英雄者，不以挫抑而灰心，不以失败而退怯</div>
</div>
<div class="sidebar-state">
  <div class="sidebar-state-article">
    <div>文章</div>
    <div class="sidebar-state-number">186</div>
  </div>
  <div class="sidebar-state-category">
    <div>分类</div>
    <div class="sidebar-state-number">4</div>
  </div>
  <div class="sidebar-state-tag">
    <div>标签</div>
    <div class="sidebar-state-number">179</div>
  </div>
</div>
<div class="sidebar-social">
  
</div>
<div class="sidebar-menu">
  
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/" aria-label="首页"></a>
        <div class="sidebar-menu-icon icon rotate">
          &#xe62b;
        </div>
        <div class="sidebar-menu-link">首页</div>
      </div>
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/archives" aria-label="归档"></a>
        <div class="sidebar-menu-icon icon rotate">
          &#xe62b;
        </div>
        <div class="sidebar-menu-link">归档</div>
      </div>
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/about" aria-label="关于"></a>
        <div class="sidebar-menu-icon icon rotate">
          &#xe62b;
        </div>
        <div class="sidebar-menu-link">关于</div>
      </div>
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/friend" aria-label="友链"></a>
        <div class="sidebar-menu-icon icon rotate">
          &#xe62b;
        </div>
        <div class="sidebar-menu-link">友链</div>
      </div>
    
  
</div>
</div>
    
  </div>
  
    <div class="sidebar-btn-wrapper">
      <div class="sidebar-toc-btn current"></div>
      <div class="sidebar-common-btn"></div>
    </div>
  
</nav>

    </div>
    
    
<script src="https://npm.webcache.cn/lazysizes@5.3.2/lazysizes.min.js" integrity="sha384-3gT&#x2F;vsepWkfz&#x2F;ff7PpWNUeMzeWoH3cDhm&#x2F;A8jM7ouoAK0&#x2F;fP&#x2F;9bcHHR5kHq2nf+e" crossorigin="anonymous"></script>


<script src="https://npm.webcache.cn/clipboard@2.0.11/dist/clipboard.min.js" integrity="sha384-J08i8An&#x2F;QeARD9ExYpvphB8BsyOj3Gh2TSh1aLINKO3L0cMSH2dN3E22zFoXEi0Q" crossorigin="anonymous"></script>



<script src="/js/script.js"></script>



  
<script src="/js/aos.js"></script>

  <script>
    var aosInit = () => {
      AOS.init({
        duration: 1000,
        easing: "ease",
        once: true,
        offset: 50,
      });
    };
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', aosInit);
    } else {
      aosInit();
    }
  </script>



<script src="/js/pjax_script.js" data-pjax></script>







  
<script src="https://npm.webcache.cn/mouse-firework@0.0.6/dist/index.umd.js" integrity="sha384-vkGvf25gm1C1PbcoD5dNfc137HzNL&#x2F;hr1RKA5HniJOaawtvUmH5lTVFgFAruE9Ge" crossorigin="anonymous"></script>

  <script>
    window.firework && window.firework(JSON.parse('{"excludeElements":["a","button"],"particles":[{"shape":"circle","move":["emit"],"easing":"easeOutExpo","colors":["#ff5252","#ff7c7c","#ffafaf","#ffd0d0"],"number":20,"duration":[1200,1800],"shapeOptions":{"radius":[16,32],"alpha":[0.3,0.5]}},{"shape":"circle","move":["diffuse"],"easing":"easeOutExpo","colors":["#ff0000"],"number":1,"duration":[1200,1800],"shapeOptions":{"radius":20,"alpha":[0.2,0.5],"lineWidth":6}}]}'))
  </script>










<div id="lazy-script">
  <div>
    
      
      
      <script data-pjax>
        window.REIMU_POST = {
          author: "FuB0Y",
          title: "Crypto-块加密",
          url: "http://example.com/2025/08/10/Crypto-%E5%9D%97%E5%8A%A0%E5%AF%86/",
          excerpt: "",
          description: "",
          stripContent: " AES 一种对称、分组加密算法  三个基本概念 密钥、填充、模式  密钥 AES 支持 3 种长度的密码 128 位、192 位、256 位。 从安全性来看，AES256 安全性最高。从性能来看，AES128 性能最高 AES 的加密标准中，每个分组的 长度固定为 128bits (16Bytes)，密钥长度为 128bits，192bits，256bits, 不同的密钥长度有不同的加密轮数，根据长度不同可以分为 AES-128，AES-192，AES-256。    AES 加密 密钥长度 ",
          date: "Sun Aug 10 2025 10:39:43 GMT+0800",
          updated: "Sat Sep 27 2025 16:55:04 GMT+0800",
          cover: "/images/banner.webp",
        };
      </script>
       
    
    
      
        
<script src="/js/insert_highlight.js" data-pjax></script>

        
      
    
    
      <script type="module" data-pjax>
        const PhotoSwipeLightbox = (await safeImport("https://npm.webcache.cn/photoswipe@5.4.4/dist/photoswipe-lightbox.esm.min.js", "sha384-DiL6M/gG+wmTxmCRZyD1zee6lIhawn5TGvED0FOh7fXcN9B0aZ9dexSF/N6lrZi/")).default;
        
        const pswp = () => {
          if (_$$('.article-entry a.article-gallery-item').length > 0) {
            new PhotoSwipeLightbox({
              gallery: '.article-entry',
              children: 'a.article-gallery-item',
              pswpModule: () => safeImport("https://npm.webcache.cn/photoswipe@5.4.4/dist/photoswipe.esm.min.js", "sha384-WkkO3GCmgkC3VQWpaV8DqhKJqpzpF9JoByxDmnV8+oTJ7m3DfYEWX1fu1scuS4+s")
            }).init();
          }
          if(_$$('.article-gallery a.article-gallery-item').length > 0) {
            new PhotoSwipeLightbox({
              gallery: '.article-gallery',
              children: 'a.article-gallery-item',
              pswpModule: () => safeImport("https://npm.webcache.cn/photoswipe@5.4.4/dist/photoswipe.esm.min.js", "sha384-WkkO3GCmgkC3VQWpaV8DqhKJqpzpF9JoByxDmnV8+oTJ7m3DfYEWX1fu1scuS4+s")
            }).init();
          }
          window.lightboxStatus = 'done';
          window.removeEventListener('lightbox:ready', pswp);
        }
        if(window.lightboxStatus === 'ready') {
          pswp()
        } else {
          window.addEventListener('lightbox:ready', pswp);
        }
      </script>
      








    
  </div>
</div>


  <script>
    console.log(String.raw`%c 
 ______     ______     __     __    __     __  __    
/\  == \   /\  ___\   /\ \   /\ "-./  \   /\ \/\ \   
\ \  __<   \ \  __\   \ \ \  \ \ \-./\ \  \ \ \_\ \  
 \ \_\ \_\  \ \_____\  \ \_\  \ \_\ \ \_\  \ \_____\ 
  \/_/ /_/   \/_____/   \/_/   \/_/  \/_/   \/_____/ 
                                                  
`,'color: #ff5252;')
    console.log('%c Theme.Reimu v' + '1.3.0' + ' %c https://github.com/D-Sketon/hexo-theme-reimu ', 'color: white; background: #ff5252; padding:5px 0;', 'padding:4px;border:1px solid #ff5252;')
  </script>
  



  
<script src="https://npm.webcache.cn/busuanzi@2.3.0/bsz.pure.mini.js" integrity="sha384-0M75wtSkhjIInv4coYlaJU83+OypaRCIq2SukQVQX04eGTCBXJDuWAbJet56id+S" crossorigin="anonymous" async></script>




<script>
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.getRegistrations().then((registrations) => {
      for (let registration of registrations) {
        registration.unregister();
      }
    });
  }
</script>



  
    
<script src="https://npm.webcache.cn/katex@0.16.11/dist/katex.min.js" integrity="sha384-7zkQWkzuo3B5mTepMUcHkMB5jZaolc2xDwL6VFqjFALcbeS9Ggm&#x2F;Yr2r3Dy4lfFg" crossorigin="anonymous" defer data-pjax></script>

    
<script src="https://npm.webcache.cn/katex@0.16.11/dist/contrib/auto-render.min.js" integrity="sha384-43gviWU0YVjaDtb&#x2F;GhzOouOXtZMP&#x2F;7XUzwPTstBeZFe&#x2F;+rCMvRwr4yROQP43s0Xk" crossorigin="anonymous" defer onload="renderMathInElement(document.body, {delimiters: [{left: &#39;$$&#39;, right: &#39;$$&#39;, display: true},{left: &#39;$&#39;, right: &#39;$&#39;, display: false}]});" data-pjax></script>

  





  </body>
  </html>

